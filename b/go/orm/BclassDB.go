// generated by genORMModelDB.go
package orm

import (
	
	"errors"
	"fmt"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox01/b/go/models"
)

// BclassAPI is the input in POST API
// 
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model bclassAPI
type BclassAPI struct {

	models.Bclass

	// association fields
	
}

// BclassDB describes a bclass in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model bclassDB
type BclassDB struct {
	gorm.Model

	BclassAPI
}

// BclassDBs arrays bclassDBs
// swagger:response bclassDBsResponse
type BclassDBs []BclassDB

// BclassDBResponse provides response
// swagger:response bclassDBResponse
type BclassDBResponse struct {
	BclassDB
}

// ModelToORMBclassTranslate is a translation function from models object to ORM objects
func ModelToORMBclassTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that bclassStore is nil as well as bclassDBs
		if map_BclassDBID_BclassPtr != nil {
			err := errors.New("In CreateMode translation, map_BclassDBID_BclassPtr should be nil")
			return err
		}

		if map_BclassDBID_BclassDB != nil {
			err := errors.New("In CreateMode translation, map_BclassDBID_BclassDB should be nil")
			return err
		}

		if map_BclassPtr_BclassDBID != nil {
			err := errors.New("In CreateMode translation, map_BclassPtr_BclassDBID should be nil")
			return err
		}

		tmp := make(map[uint]*models.Bclass, 0)
		map_BclassDBID_BclassPtr = &tmp

		tmpDB := make(map[uint]*BclassDB, 0)
		map_BclassDBID_BclassDB = &tmpDB

		tmpID := make(map[*models.Bclass]uint, 0)
		map_BclassPtr_BclassDBID = &tmpID

		for _, bclass := range models.AllModelStore.Bclasss {

			// initiate bclass
			var bclassDB BclassDB
			bclassDB.Bclass = *bclass

			query := db.Create(&bclassDB)
			if query.Error != nil {
				return query.Error
			}

			// update stores
			(*map_BclassPtr_BclassDBID)[bclass] = bclassDB.ID
			(*map_BclassDBID_BclassPtr)[bclassDB.ID] = bclass
			(*map_BclassDBID_BclassDB)[bclassDB.ID] = &bclassDB
		}
	} else { // UpdateMode, update IDs of Pointer Fields of ORM object

		// check that bclassStore is not nil
		if map_BclassDBID_BclassPtr == nil {
			err := errors.New("In UpdateMode translation, bclassStore should not be nil")
			return err
		}

		if map_BclassDBID_BclassDB == nil {
			err := errors.New("In UpdateMode translation, bclassStore should not be nil")
			return err
		}

		// update fields of bclassDB with fields of bclass
		for _, bclass := range models.AllModelStore.Bclasss {
			bclassDBID := (*map_BclassPtr_BclassDBID)[bclass]
			bclassDB := (*map_BclassDBID_BclassDB)[bclassDBID]

			bclassDB.Bclass = *bclass
		}

		// parse model objects ot update associations
		for idx, bclass := range *map_BclassDBID_BclassPtr {

			// fetch matching bclassDB
			if bclassDB, ok := (*map_BclassDBID_BclassDB)[idx]; ok {
				// set {{Fieldname}}ID



				query := db.Save(&bclassDB)
				if query.Error != nil {
					return query.Error
				}

			} else {
				err := errors.New(
					fmt.Sprintf("In UpdateMode translation, bclassStore should not be nil %v %v",
						bclassDB, bclass))
				return err
			}
		}
	}
	return nil
}

// stores BclassDB according to their gorm ID
var map_BclassDBID_BclassDB *map[uint]*BclassDB

// stores BclassDB ID according to Bclass address
var map_BclassPtr_BclassDBID *map[*models.Bclass]uint

// stores Bclass according to their gorm ID
var map_BclassDBID_BclassPtr *map[uint]*models.Bclass

// ORMToModelBclassTranslate is a translation function from ORM object to models objects
// This function used the uint ID of the ORM object to create or update (according to translationImpact)
// maps of respectively ORM and models objects
//
// In create mode,
func ORMToModelBclassTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that bclassStores are nil

		if map_BclassDBID_BclassPtr != nil {
			err := errors.New("In CreateMode translation, Parameters bclassStore should be nil")
			return err
		}

		if map_BclassDBID_BclassDB != nil {
			err := errors.New("In CreateMode translation, parameters BclassDBStore should be nil")
			return err
		}

		// init stores
		tmp := make(map[uint]*models.Bclass, 0)
		map_BclassDBID_BclassPtr = &tmp

		tmpDB := make(map[uint]*BclassDB, 0)
		map_BclassDBID_BclassDB = &tmpDB

		tmpID := make(map[*models.Bclass]uint, 0)
		map_BclassPtr_BclassDBID = &tmpID

		models.AllModelStore.Bclasss = make([]*models.Bclass, 0)

		bclassDBArray := make([]BclassDB, 0)
		query := db.Find(&bclassDBArray)
		if query.Error != nil {
			return query.Error
		}

		// copy orm objects to the two stores
		for _, bclassDB := range bclassDBArray {

			// create entries in the tree maps.
			bclass := bclassDB.Bclass
			(*map_BclassDBID_BclassPtr)[bclassDB.ID] = &bclass

			(*map_BclassPtr_BclassDBID)[&bclass] = bclassDB.ID

			bclassDBCopy := bclassDB
			(*map_BclassDBID_BclassDB)[bclassDB.ID] = &bclassDBCopy

			// append model store with the new element
			models.AllModelStore.Bclasss = append(models.AllModelStore.Bclasss, &bclass)
		}
	} else { // UpdateMode
		// for later, update of the data field

		// check that bclassStore is not nil
		if map_BclassDBID_BclassPtr == nil {
			err := errors.New("In UpdateMode translation, bclassStore should not be nil")
			return err
		}

		if map_BclassDBID_BclassDB == nil {
			err := errors.New("In UpdateMode translation, bclassStore should not be nil")
			return err
		}

		// update fields of bclassDB with fields of bclass
		for _, bclass := range models.AllModelStore.Bclasss {
			bclassDBID := (*map_BclassPtr_BclassDBID)[bclass]
			bclassDB := (*map_BclassDBID_BclassDB)[bclassDBID]

			*bclass = bclassDB.Bclass
		}

		// parse all DB instance and update all pointer fields of the translated models instance
		for _, bclassDB := range *map_BclassDBID_BclassDB {
			bclass := (*map_BclassDBID_BclassPtr)[bclassDB.ID]
			if bclass == nil {
				err := errors.New("cannot find translated instance in models store")
				return err
			}




		}
	}

	return nil
}

func (allORMStoreStruct *AllORMStoreStruct) CreateORMBclass(bclass *models.Bclass) {

	CreateORMBclass(allORMStoreStruct.db, bclass)
}

// CreateORMBclass creates ORM{{Strucname}} in DB from bclass
func CreateORMBclass(
	db *gorm.DB,
	bclass *models.Bclass) (Error error) {

	// initiate bclass
	var bclassDB BclassDB
	bclassDB.Bclass = *bclass

	query := db.Create(&bclassDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*map_BclassPtr_BclassDBID)[bclass] = bclassDB.ID
	(*map_BclassDBID_BclassPtr)[bclassDB.ID] = bclass
	(*map_BclassDBID_BclassDB)[bclassDB.ID] = &bclassDB

	return
}

func (allORMStoreStruct *AllORMStoreStruct) DeleteORMBclass(bclass *models.Bclass) {

	DeleteORMBclass(allORMStoreStruct.db, bclass)
}


func DeleteORMBclass(
	db *gorm.DB,
	bclass *models.Bclass) (Error error) {

	bclassDBID := (*map_BclassPtr_BclassDBID)[bclass]
	bclassDB := (*map_BclassDBID_BclassDB)[bclassDBID]

	query := db.Unscoped().Delete(&bclassDB)
	if query.Error != nil {
		return query.Error
	}

	delete(*map_BclassPtr_BclassDBID, bclass)
	delete(*map_BclassDBID_BclassPtr, bclassDB.ID)
	delete(*map_BclassDBID_BclassDB, bclassDBID)

	return
}
