// generated by genORMModelDB.go
package orm

import (
	
	"errors"
	"fmt"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox01/a/go/models"
)

// AclassAPI is the input in POST API
// 
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model aclassAPI
type AclassAPI struct {

	models.Aclass

	// association fields
	
}

// AclassDB describes a aclass in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model aclassDB
type AclassDB struct {
	gorm.Model

	AclassAPI
}

// AclassDBs arrays aclassDBs
// swagger:response aclassDBsResponse
type AclassDBs []AclassDB

// AclassDBResponse provides response
// swagger:response aclassDBResponse
type AclassDBResponse struct {
	AclassDB
}

// ModelToORMAclassTranslate is a translation function from models object to ORM objects
func ModelToORMAclassTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that aclassStore is nil as well as aclassDBs
		if map_AclassDBID_AclassPtr != nil {
			err := errors.New("In CreateMode translation, map_AclassDBID_AclassPtr should be nil")
			return err
		}

		if map_AclassDBID_AclassDB != nil {
			err := errors.New("In CreateMode translation, map_AclassDBID_AclassDB should be nil")
			return err
		}

		if map_AclassPtr_AclassDBID != nil {
			err := errors.New("In CreateMode translation, map_AclassPtr_AclassDBID should be nil")
			return err
		}

		tmp := make(map[uint]*models.Aclass, 0)
		map_AclassDBID_AclassPtr = &tmp

		tmpDB := make(map[uint]*AclassDB, 0)
		map_AclassDBID_AclassDB = &tmpDB

		tmpID := make(map[*models.Aclass]uint, 0)
		map_AclassPtr_AclassDBID = &tmpID

		for _, aclass := range models.AllModelStore.Aclasss {

			// initiate aclass
			var aclassDB AclassDB
			aclassDB.Aclass = *aclass

			query := db.Create(&aclassDB)
			if query.Error != nil {
				return query.Error
			}

			// update stores
			(*map_AclassPtr_AclassDBID)[aclass] = aclassDB.ID
			(*map_AclassDBID_AclassPtr)[aclassDB.ID] = aclass
			(*map_AclassDBID_AclassDB)[aclassDB.ID] = &aclassDB
		}
	} else { // UpdateMode, update IDs of Pointer Fields of ORM object

		// check that aclassStore is not nil
		if map_AclassDBID_AclassPtr == nil {
			err := errors.New("In UpdateMode translation, aclassStore should not be nil")
			return err
		}

		if map_AclassDBID_AclassDB == nil {
			err := errors.New("In UpdateMode translation, aclassStore should not be nil")
			return err
		}

		// update fields of aclassDB with fields of aclass
		for _, aclass := range models.AllModelStore.Aclasss {
			aclassDBID := (*map_AclassPtr_AclassDBID)[aclass]
			aclassDB := (*map_AclassDBID_AclassDB)[aclassDBID]

			aclassDB.Aclass = *aclass
		}

		// parse model objects ot update associations
		for idx, aclass := range *map_AclassDBID_AclassPtr {

			// fetch matching aclassDB
			if aclassDB, ok := (*map_AclassDBID_AclassDB)[idx]; ok {
				// set {{Fieldname}}ID



				query := db.Save(&aclassDB)
				if query.Error != nil {
					return query.Error
				}

			} else {
				err := errors.New(
					fmt.Sprintf("In UpdateMode translation, aclassStore should not be nil %v %v",
						aclassDB, aclass))
				return err
			}
		}
	}
	return nil
}

// stores AclassDB according to their gorm ID
var map_AclassDBID_AclassDB *map[uint]*AclassDB

// stores AclassDB ID according to Aclass address
var map_AclassPtr_AclassDBID *map[*models.Aclass]uint

// stores Aclass according to their gorm ID
var map_AclassDBID_AclassPtr *map[uint]*models.Aclass

// ORMToModelAclassTranslate is a translation function from ORM object to models objects
// This function used the uint ID of the ORM object to create or update (according to translationImpact)
// maps of respectively ORM and models objects
//
// In create mode,
func ORMToModelAclassTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that aclassStores are nil

		if map_AclassDBID_AclassPtr != nil {
			err := errors.New("In CreateMode translation, Parameters aclassStore should be nil")
			return err
		}

		if map_AclassDBID_AclassDB != nil {
			err := errors.New("In CreateMode translation, parameters AclassDBStore should be nil")
			return err
		}

		// init stores
		tmp := make(map[uint]*models.Aclass, 0)
		map_AclassDBID_AclassPtr = &tmp

		tmpDB := make(map[uint]*AclassDB, 0)
		map_AclassDBID_AclassDB = &tmpDB

		tmpID := make(map[*models.Aclass]uint, 0)
		map_AclassPtr_AclassDBID = &tmpID

		models.AllModelStore.Aclasss = make([]*models.Aclass, 0)

		aclassDBArray := make([]AclassDB, 0)
		query := db.Find(&aclassDBArray)
		if query.Error != nil {
			return query.Error
		}

		// copy orm objects to the two stores
		for _, aclassDB := range aclassDBArray {

			// create entries in the tree maps.
			aclass := aclassDB.Aclass
			(*map_AclassDBID_AclassPtr)[aclassDB.ID] = &aclass

			(*map_AclassPtr_AclassDBID)[&aclass] = aclassDB.ID

			aclassDBCopy := aclassDB
			(*map_AclassDBID_AclassDB)[aclassDB.ID] = &aclassDBCopy

			// append model store with the new element
			models.AllModelStore.Aclasss = append(models.AllModelStore.Aclasss, &aclass)
		}
	} else { // UpdateMode
		// for later, update of the data field

		// check that aclassStore is not nil
		if map_AclassDBID_AclassPtr == nil {
			err := errors.New("In UpdateMode translation, aclassStore should not be nil")
			return err
		}

		if map_AclassDBID_AclassDB == nil {
			err := errors.New("In UpdateMode translation, aclassStore should not be nil")
			return err
		}

		// update fields of aclassDB with fields of aclass
		for _, aclass := range models.AllModelStore.Aclasss {
			aclassDBID := (*map_AclassPtr_AclassDBID)[aclass]
			aclassDB := (*map_AclassDBID_AclassDB)[aclassDBID]

			*aclass = aclassDB.Aclass
		}

		// parse all DB instance and update all pointer fields of the translated models instance
		for _, aclassDB := range *map_AclassDBID_AclassDB {
			aclass := (*map_AclassDBID_AclassPtr)[aclassDB.ID]
			if aclass == nil {
				err := errors.New("cannot find translated instance in models store")
				return err
			}




		}
	}

	return nil
}

func (allORMStoreStruct *AllORMStoreStruct) CreateORMAclass(aclass *models.Aclass) {

	CreateORMAclass(allORMStoreStruct.db, aclass)
}

// CreateORMAclass creates ORM{{Strucname}} in DB from aclass
func CreateORMAclass(
	db *gorm.DB,
	aclass *models.Aclass) (Error error) {

	// initiate aclass
	var aclassDB AclassDB
	aclassDB.Aclass = *aclass

	query := db.Create(&aclassDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*map_AclassPtr_AclassDBID)[aclass] = aclassDB.ID
	(*map_AclassDBID_AclassPtr)[aclassDB.ID] = aclass
	(*map_AclassDBID_AclassDB)[aclassDB.ID] = &aclassDB

	return
}

func (allORMStoreStruct *AllORMStoreStruct) DeleteORMAclass(aclass *models.Aclass) {

	DeleteORMAclass(allORMStoreStruct.db, aclass)
}


func DeleteORMAclass(
	db *gorm.DB,
	aclass *models.Aclass) (Error error) {

	aclassDBID := (*map_AclassPtr_AclassDBID)[aclass]
	aclassDB := (*map_AclassDBID_AclassDB)[aclassDBID]

	query := db.Unscoped().Delete(&aclassDB)
	if query.Error != nil {
		return query.Error
	}

	delete(*map_AclassPtr_AclassDBID, aclass)
	delete(*map_AclassDBID_AclassPtr, aclassDB.ID)
	delete(*map_AclassDBID_AclassDB, aclassDBID)

	return
}
